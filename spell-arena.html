<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ìŠ¤í  ì•„ë ˆë‚˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0f0e17 0%, #1a1626 50%, #2d1b69 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #gameContainer {
            width: 100%;
            max-width: 1400px;
            padding: 10px;
        }
        
        #menu {
            text-align: center;
            color: white;
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #menu h1 {
            font-size: 48px;
            background: linear-gradient(45deg, #a855f7, #ec4899, #f59e0b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            text-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { filter: brightness(1); }
            to { filter: brightness(1.2); }
        }
        
        .subtitle {
            font-size: 18px;
            color: #c4b5fd;
            margin-bottom: 20px;
        }
        
        .emoji-vs {
            font-size: 48px;
            margin: 15px 0;
            animation: bounce 1s infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        #startBtn {
            padding: 12px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #a855f7, #ec4899);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 8px 20px rgba(168, 85, 247, 0.4);
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        #startBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 30px rgba(168, 85, 247, 0.6);
        }
        
        .info-box {
            margin-top: 25px;
            text-align: left;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
            background: rgba(30, 27, 75, 0.6);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(168, 85, 247, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .info-box h3 {
            color: #a855f7;
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .info-box p {
            color: #e0e7ff;
            margin: 5px 0;
            font-size: 14px;
        }
        
        #gameScreen {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }
        
        #stats {
            background: linear-gradient(135deg, rgba(30, 27, 75, 0.9), rgba(45, 27, 105, 0.9));
            padding: 12px 20px;
            border-radius: 15px;
            border: 2px solid rgba(168, 85, 247, 0.5);
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .stat-label {
            font-size: 11px;
            opacity: 0.8;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: bold;
        }
        
        #timer {
            font-size: 24px;
            color: #a855f7;
            font-weight: bold;
            background: rgba(168, 85, 247, 0.2);
            padding: 5px 15px;
            border-radius: 10px;
        }
        
        #gameArea {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        #canvasContainer {
            position: relative;
            border: 3px solid;
            border-image: linear-gradient(45deg, #a855f7, #ec4899, #f59e0b) 1;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(168, 85, 247, 0.4);
            background: #0a0a15;
            flex: 1;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: auto;
        }
        
        .side-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 200px;
        }
        
        .control-panel {
            background: linear-gradient(135deg, rgba(30, 27, 75, 0.9), rgba(45, 27, 105, 0.9));
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(168, 85, 247, 0.5);
            backdrop-filter: blur(10px);
        }
        
        .control-panel h3 {
            color: #c4b5fd;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
        }
        
        .buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .btn {
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-size: 22px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }
        
        .btn:active:not(:disabled) {
            transform: translateY(0);
        }
        
        .btn.spell {
            background: linear-gradient(135deg, #a855f7, #ec4899);
            color: white;
        }
        
        .btn.creature {
            background: linear-gradient(135deg, #10b981, #14b8a6);
            color: white;
        }
        
        .btn:disabled {
            background: linear-gradient(135deg, #374151, #4b5563);
            color: #6b7280;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .btn-info {
            font-size: 9px;
            display: block;
            margin-top: 2px;
            opacity: 0.9;
        }
        
        @media (max-width: 1200px) {
            #gameArea {
                flex-direction: column;
            }
            
            .side-controls {
                width: 100%;
                flex-direction: row;
            }
            
            .control-panel {
                flex: 1;
            }
        }
        
        @media (max-width: 768px) {
            #menu h1 { font-size: 36px; }
            .emoji-vs { font-size: 36px; }
            #stats { font-size: 12px; padding: 10px; }
            .stat-value { font-size: 14px; }
            #timer { font-size: 18px; }
            .side-controls { display: none; }
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <div id="menu">
        <h1>âš”ï¸ ìŠ¤í  ì•„ë ˆë‚˜ âš”ï¸</h1>
        <p class="subtitle">ì‹¤ì‹œê°„ ì•¡ì…˜ ë§ˆë²• ì „íˆ¬</p>
        <div class="emoji-vs">ğŸ§™â€â™‚ï¸ VS ğŸ§™â€â™€ï¸</div>
        <button id="startBtn">âš¡ ê²Œì„ ì‹œì‘ âš¡</button>
        <div class="info-box">
            <h3>ğŸ® ì¡°ì‘ë²•</h3>
            <p>â€¢ ì´ë™: ë°©í–¥í‚¤ ë˜ëŠ” WASD</p>
            <p>â€¢ ì£¼ë¬¸: ìˆ«ìí‚¤ 1-4 (ì ê³¼ í¬ë¦¬ì²˜ ê³µê²©)</p>
            <p>â€¢ í¬ë¦¬ì²˜: Q, W, E, R (ìë™ìœ¼ë¡œ ì  ì¶”ì )</p>
            <h3 style="margin-top: 15px;">ğŸ’¡ ê²Œì„ íŒ</h3>
            <p>â€¢ í¬ë¦¬ì²˜ëŠ” í•œ ë°©ì— ì£½ìŠµë‹ˆë‹¤!</p>
            <p>â€¢ ì£¼ë¬¸ìœ¼ë¡œ ì  í¬ë¦¬ì²˜ë¥¼ ë¨¼ì € ì œê±°í•˜ì„¸ìš”</p>
            <p>â€¢ ì ì˜ HPë¥¼ 0ìœ¼ë¡œ ë§Œë“¤ë©´ ìŠ¹ë¦¬!</p>
        </div>
    </div>

    <div id="gameScreen">
        <div id="stats">
            <div class="stat-item">
                <span class="stat-label" style="color: #60a5fa;">ğŸ§™â€â™‚ï¸ í”Œë ˆì´ì–´</span>
                <div class="stat-value">â¤ï¸ <span id="playerHp">20</span></div>
                <div class="stat-value">ğŸ’§ <span id="playerMana">5</span></div>
            </div>
            <div id="timer">0:00</div>
            <div class="stat-item" style="text-align: right;">
                <span class="stat-label" style="color: #ef4444;">ğŸ§™â€â™€ï¸ AI</span>
                <div class="stat-value"><span id="enemyHp">20</span> â¤ï¸</div>
                <div class="stat-value"><span id="enemyMana">5</span> ğŸ’§</div>
            </div>
        </div>

        <div id="gameArea">
            <!-- ì™¼ìª½ ì»¨íŠ¸ë¡¤ -->
            <div class="side-controls">
                <div class="control-panel">
                    <h3>ğŸ”¥ ì£¼ë¬¸</h3>
                    <div class="buttons">
                        <button class="btn spell" data-spell="0" title="ìˆ«ìí‚¤ 1">
                            <div>ğŸ”¥</div>
                            <span class="btn-info">1 | ğŸ’§2</span>
                        </button>
                        <button class="btn spell" data-spell="1" title="ìˆ«ìí‚¤ 2">
                            <div>ğŸ’š</div>
                            <span class="btn-info">2 | ğŸ’§2</span>
                        </button>
                        <button class="btn spell" data-spell="2" title="ìˆ«ìí‚¤ 3">
                            <div>âš¡</div>
                            <span class="btn-info">3 | ğŸ’§3</span>
                        </button>
                        <button class="btn spell" data-spell="3" title="ìˆ«ìí‚¤ 4">
                            <div>â„ï¸</div>
                            <span class="btn-info">4 | ğŸ’§2</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- ì¤‘ì•™ ê²Œì„ í™”ë©´ -->
            <div id="canvasContainer">
                <canvas id="canvas" width="1000" height="700"></canvas>
            </div>

            <!-- ì˜¤ë¥¸ìª½ ì»¨íŠ¸ë¡¤ -->
            <div class="side-controls">
                <div class="control-panel">
                    <h3>âš”ï¸ í¬ë¦¬ì²˜</h3>
                    <div class="buttons">
                        <button class="btn creature" data-creature="0" title="Qí‚¤">
                            <div>âš”ï¸</div>
                            <span class="btn-info">Q | ğŸ’§2</span>
                        </button>
                        <button class="btn creature" data-creature="1" title="Wí‚¤">
                            <div>ğŸ¹</div>
                            <span class="btn-info">W | ğŸ’§3</span>
                        </button>
                        <button class="btn creature" data-creature="2" title="Eí‚¤">
                            <div>ğŸ›¡ï¸</div>
                            <span class="btn-info">E | ğŸ’§4</span>
                        </button>
                        <button class="btn creature" data-creature="3" title="Rí‚¤">
                            <div>ğŸ”®</div>
                            <span class="btn-info">R | ğŸ’§3</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let gameState = 'menu';
    let player = {
        hp: 20,
        maxHp: 20,
        mana: 5,
        maxMana: 5,
        x: 200,
        y: 350,
        speed: 5,
        creatures: [],
        facing: 'right',
        meleeCooldown: 0
    };

    let enemy = {
        hp: 20,
        maxHp: 20,
        mana: 5,
        maxMana: 5,
        x: 800,
        y: 350,
        creatures: [],
        facing: 'left'
    };

    let projectiles = [];
    let gameTime = 0;
    let lastSpellCast = {};
    let keys = {};

    let aiMoveTarget = { x: 800, y: 350 };

    const spells = [
        { name: 'í™”ì—¼êµ¬', cost: 2, type: 'projectile', damage: 3, speed: 7, size: 15, color: '#ff4444', icon: 'ğŸ”¥', cooldown: 800 },
        { name: 'ì¹˜ìœ ', cost: 2, type: 'heal', power: 4, icon: 'ğŸ’š', cooldown: 2000 },
        { name: 'ë²ˆê°œ', cost: 3, type: 'projectile', damage: 4, speed: 12, size: 12, color: '#ffff00', icon: 'âš¡', cooldown: 1200 },
        { name: 'ì–¼ìŒ', cost: 2, type: 'projectile', damage: 4, speed: 6, size: 18, color: '#4444ff', icon: 'â„ï¸', cooldown: 600 }
    ];

    const creatures = [
        { name: 'ê²€ì‚¬', cost: 2, hp: 1, attack: 2, speed: 2, icon: 'âš”ï¸', size: 25, color: '#2ecc71' },
        { name: 'ê¶ìˆ˜', cost: 3, hp: 1, attack: 3, speed: 1, icon: 'ğŸ¹', size: 22, color: '#3498db' },
        { name: 'ë°©íŒ¨ë³‘', cost: 2, hp: 2, attack: 0, speed: 0, icon: 'ğŸ›¡ï¸', size: 28, color: '#9b59b6', type: 'shield' },
        { name: 'ë§ˆë²•ì‚¬', cost: 3, hp: 1, attack: 5, speed: 1.5, icon: 'ğŸ”®', size: 22, color: '#e74c3c' }
    ];

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    document.getElementById('startBtn').addEventListener('click', () => {
        document.getElementById('menu').style.display = 'none';
        document.getElementById('gameScreen').style.display = 'block';
        gameState = 'playing';
        startGame();
    });

    function startGame() {
        player = {
            hp: 20,
            maxHp: 20,
            mana: 5,
            maxMana: 5,
            x: 200,
            y: 350,
            speed: 5,
            creatures: [],
            facing: 'right',
            meleeCooldown: 0
        };

        enemy = {
            hp: 20,
            maxHp: 20,
            mana: 5,
            maxMana: 5,
            x: 800,
            y: 350,
            creatures: [],
            facing: 'left',
            meleeCooldown: 0
        };

        projectiles = [];
        gameTime = 0;
        lastSpellCast = {};

        gameLoop();
    }

    document.addEventListener('keydown', (e) => {
        keys[e.key] = true;

        if (gameState !== 'playing') return;

        if (e.key === 'Control') {
            tryMeleeAttack();
        }

        const num = parseInt(e.key);
        if (num >= 1 && num <= 4) {
            castSpell(num - 1);
        }

        if (e.key.toLowerCase() === 'q') summonCreature(0);
        if (e.key.toLowerCase() === 'w') summonCreature(1);
        if (e.key.toLowerCase() === 'e') summonCreature(2);
        if (e.key.toLowerCase() === 'r') summonCreature(3);
    });

    document.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    document.querySelectorAll('.btn.spell').forEach((btn, index) => {
        btn.addEventListener('click', () => castSpell(index));
    });

    document.querySelectorAll('.btn.creature').forEach((btn, index) => {
        btn.addEventListener('click', () => summonCreature(index));
    });

    function castSpell(index) {
        const spell = spells[index];
        if (player.mana < spell.cost) return;

        const now = Date.now();
        if (lastSpellCast[index] && now - lastSpellCast[index] < spell.cooldown) {
            return;
        }

        if (spell.type === 'projectile') {
            const xOffset = player.facing === 'right' ? 40 : -40;
            projectiles.push({
                x: player.x + xOffset,
                y: player.y,
                velocityX: spell.speed * (player.facing === 'right' ? 1 : -1),
                velocityY: 0,
                damage: spell.damage,
                size: spell.size,
                color: spell.color,
                owner: 'player'
            });
            player.mana -= spell.cost;
        } else if (spell.type === 'heal') {
            player.hp = Math.min(player.maxHp, player.hp + spell.power);
            player.mana -= spell.cost;
        }

        lastSpellCast[index] = now;
        updateUI();
    }

    function summonCreature(index) {
        const creature = creatures[index];
        if (player.mana < creature.cost || player.creatures.length >= 10) return;

        player.creatures.push({
            ...creature,
            id: Date.now() + Math.random(),
            x: player.x + 60,
            y: player.y + (Math.random() - 0.5) * 150,
            currentHp: creature.hp,
            facing: 'right'
        });

        player.mana -= creature.cost;
        updateUI();
    }

    function updateUI() {
        document.getElementById('playerHp').textContent = Math.floor(player.hp);
        document.getElementById('playerMana').textContent = Math.floor(player.mana);
        document.getElementById('enemyHp').textContent = Math.floor(enemy.hp);
        document.getElementById('enemyMana').textContent = Math.floor(enemy.mana);

        const minutes = Math.floor(gameTime / 60);
        const seconds = gameTime % 60;
        document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

        document.querySelectorAll('.btn.spell').forEach((btn, index) => {
            btn.disabled = player.mana < spells[index].cost;
        });

        document.querySelectorAll('.btn.creature').forEach((btn, index) => {
            btn.disabled = player.mana < creatures[index].cost || player.creatures.length >= 10;
        });
    }

    function drawCharacter(x, y, color, facing, label) {
        // ê·¸ë¦¼ì
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.beginPath();
        ctx.ellipse(x, y + 35, 28, 10, 0, 0, Math.PI * 2);
        ctx.fill();

        // ëª¸í†µ
        const gradient = ctx.createLinearGradient(x - 20, y - 20, x + 20, y + 30);
        gradient.addColorStop(0, color);
        gradient.addColorStop(1, color + 'cc');
        ctx.fillStyle = gradient;
        ctx.fillRect(x - 18, y - 18, 36, 42);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(x - 18, y - 18, 36, 42);

        // ë¨¸ë¦¬
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.arc(x, y - 32, 18, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.stroke();

        // ëˆˆ
        ctx.fillStyle = '#000';
        const eyeX = facing === 'right' ? 6 : -6;
        ctx.fillRect(x + eyeX - 4, y - 35, 4, 4);
        ctx.fillRect(x + eyeX + 4, y - 35, 4, 4);

        // íŒ”
        const armBounce = Math.sin(Date.now() / 150) * 8;
        ctx.strokeStyle = color;
        ctx.lineWidth = 12;
        ctx.lineCap = 'round';

        const armDir = facing === 'right' ? 1 : -1;

        ctx.beginPath();
        ctx.moveTo(x - 18, y - 8);
        ctx.lineTo(x - 32 * armDir, y + 10 + armBounce);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x + 18, y - 8);
        ctx.lineTo(x + 40 * armDir, y + 6 - armBounce);
        ctx.stroke();

        // ë‹¤ë¦¬
        ctx.lineWidth = 14;
        const legBounce = Math.sin(Date.now() / 120) * 5;

        ctx.beginPath();
        ctx.moveTo(x - 8, y + 24);
        ctx.lineTo(x - 8, y + 40 + legBounce);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x + 8, y + 24);
        ctx.lineTo(x + 8, y + 40 - legBounce);
        ctx.stroke();

        // HP ë°”
        const hp = label === 'í”Œë ˆì´ì–´' ? player.hp / player.maxHp : enemy.hp / enemy.maxHp;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(x - 40, y - 60, 80, 10);

        const hpGradient = ctx.createLinearGradient(x - 40, 0, x + 40, 0);
        if (label === 'í”Œë ˆì´ì–´') {
            hpGradient.addColorStop(0, '#10b981');
            hpGradient.addColorStop(1, '#059669');
        } else {
            hpGradient.addColorStop(0, '#ef4444');
            hpGradient.addColorStop(1, '#dc2626');
        }
        ctx.fillStyle = hpGradient;
        ctx.fillRect(x - 40, y - 60, 80 * hp, 10);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(x - 40, y - 60, 80, 10);

        // ë¼ë²¨
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = color;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 4;
        ctx.strokeText(label, x, y - 72);
        ctx.fillText(label, x, y - 72);
    }

    function render() {
        // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜
        const gradient = ctx.createLinearGradient(0, 0, 0, 700);
        gradient.addColorStop(0, '#0f0e17');
        gradient.addColorStop(0.5, '#1a1626');
        gradient.addColorStop(1, '#2d1b69');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 1000, 700);

        // ë³„ íš¨ê³¼
        ctx.fillStyle = '#ffffff';
        for (let i = 0; i < 80; i++) {
            const x = (i * 137) % 1000;
            const y = (i * 197) % 700;
            const size = (i % 3) * 0.5 + 0.5;
            const twinkle = Math.sin(Date.now() / 500 + i) * 0.5 + 0.5;
            ctx.globalAlpha = twinkle * 0.6;
            ctx.fillRect(x, y, size, size);
        }
        ctx.globalAlpha = 1;

        // ì¤‘ì•™ì„ 
        ctx.strokeStyle = '#a855f7';
        ctx.lineWidth = 4;
        ctx.setLineDash([15, 15]);
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#a855f7';
        ctx.beginPath();
        ctx.moveTo(500, 0);
        ctx.lineTo(500, 700);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.shadowBlur = 0;

        // í”Œë ˆì´ì–´ í¬ë¦¬ì²˜
        player.creatures.forEach(creature => {
            ctx.fillStyle = creature.color;
            ctx.shadowBlur = 25;
            ctx.shadowColor = creature.color;
            ctx.beginPath();
            ctx.arc(creature.x, creature.y, creature.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = `bold ${creature.size + 10}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(creature.icon, creature.x, creature.y);
        });

        // ì  í¬ë¦¬ì²˜
        enemy.creatures.forEach(creature => {
            ctx.fillStyle = '#e67e22';
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#e67e22';
            ctx.beginPath();
            ctx.arc(creature.x, creature.y, creature.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = `bold ${creature.size + 10}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(creature.icon, creature.x, creature.y);
        });

        // ë°œì‚¬ì²´
        projectiles.forEach(proj => {
            ctx.fillStyle = proj.color;
            ctx.shadowBlur = 30;
            ctx.shadowColor = proj.color;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // ê¼¬ë¦¬ íš¨ê³¼
            for (let i = 1; i <= 3; i++) {
                ctx.fillStyle = proj.color + '60';
                ctx.beginPath();
                ctx.arc(
                    proj.x - proj.velocityX * i * 1.5,
                    proj.y - proj.velocityY * i * 1.5,
                    proj.size * (1 - i * 0.2),
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
        });

        // ìºë¦­í„°
        drawCharacter(player.x, player.y, '#60a5fa', player.facing, 'í”Œë ˆì´ì–´');
        drawCharacter(enemy.x, enemy.y, '#ef4444', enemy.facing, 'AI');

        // ğŸ—¡ï¸ ê·¼ì ‘ ê³µê²© ì´í™íŠ¸ (ë§¨ ë§ˆì§€ë§‰!)
        if (Date.now() < player.meleeCooldown) {
            ctx.strokeStyle = '#facc15';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(player.x, player.y, 70, 0, Math.PI * 2);
            ctx.stroke();
        }
    }

    function update() {
        if (gameState !== 'playing') return;

        // í”Œë ˆì´ì–´ ì´ë™
        if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
            player.x = Math.max(60, player.x - player.speed);
            player.facing = 'left';
        }
        if (keys['ArrowRight'] || keys['d'] || keys['D']) {
            player.x = Math.min(450, player.x + player.speed);
            player.facing = 'right';
        }
        if (keys['ArrowUp'] || keys['w'] || keys['W']) {
            player.y = Math.max(80, player.y - player.speed);
        }
        if (keys['ArrowDown'] || keys['s'] || keys['S']) {
            player.y = Math.min(620, player.y + player.speed);
        }

        // ğŸ¤– AI ëœë¤ ì´ë™
        if (Math.random() < 0.02) {
            aiMoveTarget.x = 550 + Math.random() * 350;
            aiMoveTarget.y = 100 + Math.random() * 500;
        }

        const dxAI = aiMoveTarget.x - enemy.x;
        const dyAI = aiMoveTarget.y - enemy.y;
        const distAI = Math.sqrt(dxAI * dxAI + dyAI * dyAI);

        if (distAI > 5) {
            enemy.x += (dxAI / distAI) * 2;
            enemy.y += (dyAI / distAI) * 2;
        }

        // í”Œë ˆì´ì–´ ë„ˆë¬´ ê°€ê¹Œìš°ë©´ íšŒí”¼
        const pdx = player.x - enemy.x;
        const pdy = player.y - enemy.y;
        const pdist = Math.sqrt(pdx * pdx + pdy * pdy);

        if (pdist < 120) {
            enemy.x -= (pdx / pdist) * 3;
            enemy.y -= (pdy / pdist) * 3;
        }

        // ë°œì‚¬ì²´ ì´ë™ ë° ì¶©ëŒ
        projectiles = projectiles.filter(proj => {
            proj.x += proj.velocityX;
            proj.y += proj.velocityY;

            if (proj.owner === 'player') {
                // ì  ìºë¦­í„°ì™€ ì¶©ëŒ
                if (Math.abs(proj.x - enemy.x) < 40 && Math.abs(proj.y - enemy.y) < 40) {
                    enemy.hp = Math.max(0, enemy.hp - proj.damage);
                    updateUI();
                    return false;
                }

                // ì  í¬ë¦¬ì²˜ì™€ ì¶©ëŒ - í•œë°©ì— ì£½ìŒ
                const hitIndex = enemy.creatures.findIndex(c =>
                    Math.abs(proj.x - c.x) < c.size + proj.size &&
                    Math.abs(proj.y - c.y) < c.size + proj.size
                );
                if (hitIndex !== -1) {
                    const c = enemy.creatures[hitIndex];

                    if (c.type === 'shield') {
                        // ğŸ›¡ï¸ ë°©íŒ¨ë³‘ì€ 2ë²ˆê¹Œì§€ ë²„íŒ€
                        c.currentHp -= 1;

                        if (c.currentHp <= 0) {
                            enemy.creatures.splice(hitIndex, 1);
                        }
                    } else {
                        // ì¼ë°˜ í¬ë¦¬ì²˜ëŠ” í•œë°©
                        enemy.creatures.splice(hitIndex, 1);
                    }

                    // íˆ¬ì‚¬ì²´ëŠ” ì—¬ê¸°ì„œ ë¬´ì¡°ê±´ ì†Œë©¸
                    return false;
                }
            } else {
                // í”Œë ˆì´ì–´ ìºë¦­í„°ì™€ ì¶©ëŒ
                if (Math.abs(proj.x - player.x) < 40 && Math.abs(proj.y - player.y) < 40) {
                    player.hp = Math.max(0, player.hp - proj.damage);
                    updateUI();
                    return false;
                }

                // í”Œë ˆì´ì–´ í¬ë¦¬ì²˜ì™€ ì¶©ëŒ - í•œë°©ì— ì£½ìŒ
                const hitIndex = player.creatures.findIndex(c =>
                Math.abs(proj.x - c.x) < c.size + proj.size &&
                Math.abs(proj.y - c.y) < c.size + proj.size
            );

            if (hitIndex !== -1) {
                const c = player.creatures[hitIndex];

                if (c.type === 'shield') {
                    c.currentHp -= 1;

                    if (c.currentHp <= 0) {
                        player.creatures.splice(hitIndex, 1);
                    }
                } else {
                    player.creatures.splice(hitIndex, 1);
                }

                return false;
            }
        }

            return proj.x > 0 && proj.x < 1000 && proj.y > 0 && proj.y < 700;
        });

        // í”Œë ˆì´ì–´ í¬ë¦¬ì²˜ AI
        for (let i = player.creatures.length - 1; i >= 0; i--) {
            const creature = player.creatures[i];

            // ğŸ›¡ï¸ ë°©íŒ¨ë³‘ì€ ì´ë™/ê³µê²© ì•ˆ í•¨
            if (creature.type === 'shield') continue;

            // ğŸ”¥ ëª©í‘œëŠ” ì !
            const dx = enemy.x - creature.x;
            const dy = enemy.y - creature.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 40) {
                creature.x += (dx / distance) * creature.speed;
                creature.y += (dy / distance) * creature.speed;
            } else {
                // ğŸ’¥ ì ì—ê²Œ í”¼í•´
                enemy.hp = Math.max(0, enemy.hp - creature.attack);
                updateUI();

                // â— ê³µê²© í›„ ìê¸° ìì‹  ì œê±°
                player.creatures.splice(i, 1);
            }
        }

        // ì  í¬ë¦¬ì²˜ AI
        for (let i = enemy.creatures.length - 1; i >= 0; i--) {
            const creature = enemy.creatures[i];

            // ğŸ›¡ï¸ ë°©íŒ¨ë³‘ì€ ì´ë™/ê³µê²© ì•ˆ í•¨
            if (creature.type === 'shield') continue;

            // ğŸ”¥ ëª©í‘œëŠ” í”Œë ˆì´ì–´!
            const dx = player.x - creature.x;
            const dy = player.y - creature.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 40) {
                creature.x += (dx / distance) * creature.speed;
                creature.y += (dy / distance) * creature.speed;
            } else {
                // ğŸ’¥ í”Œë ˆì´ì–´ì—ê²Œ í”¼í•´
                player.hp = Math.max(0, player.hp - creature.attack);
                updateUI();

                // â— ê³µê²© í›„ ìê¸° ìì‹  ì œê±°
                enemy.creatures.splice(i, 1);
            }
        }

        // ìŠ¹íŒ¨ ì²´í¬
        if (player.hp <= 0 || enemy.hp <= 0) {
            gameState = 'gameover';
            setTimeout(() => {
                const result = player.hp > 0 ? 'ğŸ‰ ìŠ¹ë¦¬! ğŸ‰' : 'ğŸ’€ íŒ¨ë°° ğŸ’€';
                if (confirm(result + '\n\në‹¤ì‹œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    location.reload();
                }
            }, 100);
        }
    }

    function gameLoop() {
        if (gameState === 'playing') {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
    }

    function tryMeleeAttack() {
        const now = Date.now();
        if (now < player.meleeCooldown) return;

        const MELEE_RANGE = 70;
        const MELEE_COOLDOWN = 600; // ms

        for (let i = enemy.creatures.length - 1; i >= 0; i--) {
            const c = enemy.creatures[i];
            const dx = c.x - player.x;
            const dy = c.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist <= MELEE_RANGE) {
                if (c.type === 'shield') {
                    c.currentHp -= 1;
                    if (c.currentHp <= 0) {
                        enemy.creatures.splice(i, 1);
                    }
                } else {
                    enemy.creatures.splice(i, 1);
                }
            }
        }

        // ì¿¨íƒ€ì„ ì„¤ì •
        player.meleeCooldown = now + MELEE_COOLDOWN;
    }

    // ë§ˆë‚˜ ì¶©ì „ ë° AI
    setInterval(() => {
        if (gameState !== 'playing') return;

        player.mana = Math.min(player.mana + 0.5, player.maxMana);
        enemy.mana = Math.min(enemy.mana + 0.5, enemy.maxMana);
        gameTime++;
        updateUI();

        // ğŸ¤– AI ìŠ¤í  ì‚¬ìš©
        if (enemy.mana >= 2 && Math.random() < 0.4) {
            const spellIndex = Math.floor(Math.random() * spells.length);
            const spell = spells[spellIndex];

            if (enemy.mana >= spell.cost) {
                if (spell.type === 'projectile') {
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);

                    projectiles.push({
                        x: enemy.x - 40,
                        y: enemy.y,
                        velocityX: Math.cos(angle) * spell.speed,
                        velocityY: Math.sin(angle) * spell.speed,
                        damage: spell.damage,
                        size: spell.size,
                        color: spell.color,
                        owner: 'enemy'
                    });

                    enemy.mana -= spell.cost;
                }

                if (spell.type === 'heal' && enemy.hp < enemy.maxHp * 0.6) {
                    enemy.hp = Math.min(enemy.maxHp, enemy.hp + spell.power);
                    enemy.mana -= spell.cost;
                }
            }
        }

        // ğŸ¤– AI í¬ë¦¬ì²˜ ì†Œí™˜
        if (
            enemy.mana >= 2 &&
            enemy.creatures.length < 5 &&
            Math.random() < 0.35
        ) {
            const creatureIndex = Math.floor(Math.random() * creatures.length);
            const creature = creatures[creatureIndex];

            if (enemy.mana >= creature.cost) {
                enemy.creatures.push({
                    ...creature,
                    id: Date.now() + Math.random(),
                    x: enemy.x - 60,
                    y: enemy.y + (Math.random() - 0.5) * 200,
                    currentHp: creature.hp,
                    facing: 'left'
                });

                enemy.mana -= creature.cost;
            }
        }
    }, 1000);
</script>
</body>
</html>
